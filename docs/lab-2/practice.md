## 实验二：内存分配

### 实验之前

- 阅读实验指导二。
- checkout 到仓库中的 `lab-2` 分支，实验题将以此展开。

### 实验题

1.  回答：我们在动态内存分配中实现了一个堆，它允许我们在内核代码中使用动态分配的内存，例如 `Vec` `Box` 等。那么，如果我们在实现这个堆的过程中使用 `Vec` 而不是 `[u8]`，会出现什么结果？

    - 无法编译？

    - 运行时错误？

    - 正常运行？
    <br>

    {% reveal %}
> **都不会！**程序会陷入一个循环：它需要在堆上分配空间，但是分配器又需要在堆上分配空间……
    {% endreveal %}

    <br>
2.  实验
    1.  回答：`algorithm/src/allocator` 下有一个 `Allocator` trait，我们之前用它实现了物理页面分配。这个算法的时间和空间复杂度是什么？

        {% reveal %}
> 时间复杂度是 O(1)，空间复杂度是 O(n)
        {% endreveal %}

        <br>
    2.  二选一：实现基于线段树的物理页面分配算法（不需要考虑合并分配）；或尝试修改 `FrameAllocator`，令其使用未被分配的页面空间（而不是全局变量）来存放页面使用状态。

    <br>
3.  挑战实验（选做）
    1.  在 `memory/heap2.rs` 中，提供了一个手动实现堆的方法。它使用 `algorithm::VectorAllocator` 作为其根本分配算法，而我们目前提供了一个非常简单的 bitmap 算法（而且只开了很小的空间）。请在 `algorithm` crate 中利用伙伴算法实现 `VectorAllocator` trait。

        <br>
    2.  前面说到，堆的实现本身不能使用动态内存分配。有没有什么方法能够让堆本身也能够利用 `Vec` 来动态分配空间？

        {% reveal %}
> 堆所用到的最初一部分空间必须静态分配，而随着使用空间增加，增量的部分实际上可以用 `Vec` 等来实现。
        {% endreveal %}
